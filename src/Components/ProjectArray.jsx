const projectArray = [
  {
    id: 0,
    link:'https://codepen.io/joshleewillis/full/qEWRjzN',
    src: './src/assets/Project-Screenshots/8.25+5Clock.PNG',
    title: '25 + 5 Clock',
    description: `The 25 + 5 clock was the last project that I made for the FreeCodeCamp Front End Development Libraries course. The purpose of this app is a productivity clock for users. They can set the time for their work and break sessions. When the time is up for the work session, the timer alarm goes off and the break session starts automatically. When the break ends, the alarm goes off, starting the work session and resetting the cycle. Users can reset the cycle at any time by clicking the reset button, which will stop the timer and revert the session and break times back to 25 and 5, respectively.

    I was able to keep everything for this app in a single main component. I used the hooks useState, useEffect, and useRef. I created state to manage the break length, session length, timer label, a boolean for isPlaying, and the amount of time left. I used useRef to manage the alarm that sounds when a timer runs out. I kept the time lengths for break and session in seconds so the timer could run smoothly. I displayed the break and session lengths in minutes by making constants that reference the state for those values divided by 60 and rounded. I then displayed those in their proper JSX elements. I created a function to display the value for time left in mm:ss format, which takes a number in seconds as an argument. That is also passed to the appropriate JSX element with the state for time left as its argument in order to display the time left on the timer in the appropriate format. 
    
    The first event handler that I wrote was for handling increment and decrement of the break and session lengths. Inside it, I set a minimum value of 1 minute and a maximum value of 60 minutes, which was a requirement for the project. I also prevented the function from running if the timer was currently playing. I wrote four separate conditions for the function, two for break decrement and increment, and two for session decrement and increment. Each condition checks for the id of the button getting pressed and runs the correct condition. The decrement buttons are prevented from running if the value is at the minimum value of 1, and the increment buttons are prevented from running if the value is at the maximum of 60. Depending on which button is pressed, the appropriate state for break or session length is updated. There is a nested condition to check if the value getting updated is the same as the timer label (break or session), and the time left state gets updated if so. I wrote another nested condition within each of these conditions to check if the value of the session or break length was different from time left, meaning that the timer had already run. If so, the break or session length subtract from time left to get the difference, and add it back to the current value of time left to get them equal. This allowed for time left and the break or session lengths to be at the same value when they get incremented or decremented. 
    
    The next event handler that I wrote was a simple function to handle the time left state. It uses an if/else condition to check if the value of time left is greater than zero, and if so, the value of time left gets decremented 1 second at a time. The else condition handles the changing of the timer label from break to session and vice versa, in addition to updating the state for time left appropriately with break or session length. This function gets called inside a useEffect condition when the isPlaying state is true. The function is called inside a set interval function to make it run once a second, ensuring that the user sees the time getting updated at that interval. The interval is cleared when the timer is paused and when the component unmounts as a cleanup function. This useEffect takes isPlaying and time left as dependencies, and the state for isPlaying gets reversed in the onClick for the start/stop button. There is also a useEffect to make the alarm go off when the state for time left reaches zero. The reference set at the beginning with useRef is played and time left is a dependency. Lastly for the event handlers, there is a function to reset all states back to their default values and stop the timer; this function also pauses and resets the alarm. 
    
    The JSX for the app maintains a simple structure with a container for the break and session lengths, and another for the timer. I used font awesome icons for the up and down arrows to represent increment and decrement for the break and session lengths, as well as for the play/pause and refresh buttons. The break and session lengths are displayed in minutes with their increment and decrement arrows on either side. In the timer container, the state for time left is displayed as an argument for the function to display it in mm:ss format. The play/pause button has the function to update the state for isPlaying inside an onClick, where the argument for the function alternates back and forth as the button is clicked. There is also a ternary condition inside the button to make the icons alternate between play and pause as the button is clicked. The refresh button follows as an icon that takes the function to reset all states and the alarm as an onClick. Lastly, the audio element for the beep alarm is in the JSX, but does not appear on the page. Its ref prop is set to the useRef hook for the alarm that was set at the beginning of the component. 
    
    This was my first project involving time and counting, which helped me learn some new programming concepts related to that. The first thing I had to learn was how to represent time in mm:ss format. I wrote a function for that, and quickly realized that I would need to keep all time in seconds. This made it more efficient to update states that were related to one another, such as the break and session lengths with the time left state, as well as decrementing time one second at a time as intended when the timer was running. I also expanded my knowledge of React state with this project. The function for incrementing and decrementing the session and break lengths in addition to the time left state proved to be a tricky task. I wrote the conditions in that function to apply the action to the appropriate state. I then used nested conditions to ensure that the state for time left was properly updated alongside break or session length depending on which one was active as the timer. This project also saw me get more experience with the useEffect hook to update DOM elements, using it to update the timer while it was playing on the page, and play the alarm when the timer hit zero. I also used and styled font awesome icons for the first time, and learned how to use the ternary condition to alternate between the play and pause icons. Making this app also saw me complete the Front End Development Libraries course for FreeCodeCamp, which served as an important milestone in my programming education and my progress as a developer.    
    `
  },
  {
    id: 1,
    link: 'https://codepen.io/joshleewillis/full/GRbVoEy',
    src: './src/assets/Project-Screenshots/7.JavaScriptCalculator.PNG', 
    title: 'JavaScript Calculator', 
    description: `I continued the FreeCodeCamp Front End Development Libraries course with the JavaScript Calculator project. This project saw me use React to create a fully functional calculator app with the basic operators: add, subtract, multiply, and divide. Users can enter decimal numbers, do chain operations of any size, and clear the screen. There were a number of tests that the project had to pass in order to be submitted, and I discuss below some of the most challenging tests and how I overcame them.

    The app is comprised of two components, a main component that houses the functionality and JSX of the app, and a separate component for the button grid. I set up state in the main component to manage the display, equation, current operator, and result. Also in the main component, I set up a reference to the last and second to last character of the equation, as well as an array containing all operators, and another array containing all operators except minus. These four constants helped me solve problems involving handling the operator, exceptions with minus/negative signs, and setting character limits for numbers and the display.
    
    My first event handler in the main component handles the operator. It simply sets the state of the operator, and has a condition to prevent multiple consecutive operators. The condition uses the four constants mentioned above to check if the last character is an operator, and if it is, it gets replaced by the newly pressed operator. I wrote a nested condition to handle situations when an operator and a negative sign had already been pressed, ensuring that they both get replaced with the newly pressed operator. In summary, this condition ensures that the most recently pressed operator gets used in the equation. 
    
    The event handler for the display is the next part of the main component, which serves the purpose of updating the display and equation states properly. Using the JavaScript method, pop, I saved a constant to reference the current number in the equation. I used this, along with the constants I saved at the beginning, to make sure required conditions were met. The first conditions I wrote were for preventing numbers from starting with zero and multiple decimal points in a number. Next I wrote a condition to check if the value was an operator, and if so, set it using the event handler for operators. Nested within that condition are a series of conditions that handle edge cases related to operators. Together they prevent the equation from starting with an operator, prevent the equation from starting with multiple negative signs or having more than two consecutive minus/negative signs, and lastly, if there is an operator and negative sign at the end of the equation, adding another negative sign is prevented. I also set a limit of 20 characters for the current number and 100 characters for the display state. When users reach these limits, they are prevented from adding more characters and they get an alert error. After all the above conditions are passed, the states for display and equation get updated properly as user input gets entered. Lastly, there is a condition to start a new equation if a result has been calculated and an operator is pressed. The new equation then begins with the previous result of the last equation and the new operator.
    
    There are some short event handlers for the equals and clear buttons. The equals button event handler has a condition in place to disallow the user from dividing by zero. There is also a condition to split consecutive minus/negative signs to make the equation run properly. The states are then updated for result, equation, and display, where equation shows the full equation equal to the result, and display shows the result only. The event handler for the clear button sets all states back to their default values when the button is pressed. 
    
    The JSX for this component maintains a simple structure. The display container at the top houses the equation and display elements. Below that is the calculator button grid component that gets passed the event handlers for updating the display, equals, and clear as props. I used the map method again to dynamically create the button grid. I used four separate divs to represent the rows on the number grid, using an array of objects for the data for each button. Here I was able to pass them their id and value, along with the function to update the display and the appropriate CSS class. The only row that was different was the last one, because the zero button took up twice as much space in the grid as the other buttons. I added the appropriate CSS class names to the objects for this row to pass them dynamically. The next column is for the operator buttons, and they are mapped the same way as before and get passed the appropriate class and function. The last column is for the clear and equals buttons. These needed to be passed different functions, so I added the appropriate one to each object and passed it dynamically to the buttons. Using map this time expanded my knowledge on that method because each row or column that I was mapping was slightly different. Some required different properties, classes, or functions than the other buttons, but I still found a way to map them dynamically as props or key/value pairs in the objects. 
    
    An important lesson that I learned in making this project was that state in React cannot be updated and displayed on the page simultaneously. I ran into this issue while handling special cases such as using the most recently pressed operator, starting a new equation after an operator has been pressed following a calculated result, and splitting the equation when a minus sign and negative sign were present consecutively. In all of these examples, I made the mistake of trying to update state and display it on the page simultaneously. I studied state in React and its behavior closely and found that it behaves asynchronously. This made it impossible to work the way I was trying it. However, I saved the updated state as a variable, and placed the variable in the set state function to update it. This worked in all the aforementioned situations! It was a necessary step to perform the action that needed to happen and update the state values properly.
    
    This was one of the most difficult projects that I had made at the time that I completed it. The challenges I mentioned above involving handling edge cases and special conditions, non-intuitive rules around React state, and using the JS map method and CSS grid to create a dynamic and visually appealing layout were all aspects of the project that pushed me forward to become a better developer. By this point in my journey, I felt confident using HTML, CSS, and JavaScript in conjunction with one another, in addition to using tools like React to efficiently create dynamic and functional web applications.     
    `
  },
  {
    id: 2,
    link: 'https://codepen.io/joshleewillis/full/ZEdoaYw',
    src: './src/assets/Project-Screenshots/6.DrumMachine.PNG', 
    title: 'Drum Machine', 
    description: `I created this project with React to continue the FreeCodeCamp Front End Development Libraries course. It emulates a midi drum machine pad, complete with nine buttons with different sounds, a power switch, volume bar, and display screen. When users press the buttons on the pad or type the letter for any button, a sound is played and the name of the sound displays on the screen. Volume can be adjusted on the bar, and the screen will also display the current volume when it is changed. Turning the power switch off stops all sound from the buttons.

    There is a main component for the functionality and JSX structure of the app, and two smaller components for the drum machine button grid and the power toggle switch. I used the useState and useEffect hooks for this project again, and I created state for the display, the power switch, and the volume, and I set up an array of objects for each pad name and the key associated with it. In the main component, I made an event handler to play audio, which does not run if the power button is not on. Taking the key as an argument, it checks the array to find the correct object to get the right pad name/key pair. The volume for the pad is set equal to the volume state to make sure it plays at the volume that the user set, and displays the drum pad in the display. 
    
    There is a useEffect to handle keydown events when the user presses keys to play a specific pad. The event handler inside finds the correct match from the pad/key array of objects to match it and call the play audio function. Also a part of this function is a condition to add a class to animate the button that is pressed. This animates the button with a keydown event the same way it would if it was clicked. It removes the class after with a short set timeout function to avoid issues with the DOM and memory leaks. The keydown event listener is also added and removed inside the useEffect for the same reason. The toggle switch and volume states are listed as dependencies since keydowns should not occur when the switch is off, and audio should play at the appropriate volume set by the user. 
    
    Lastly for the event handlers, there is a function to adjust the volume. It is passed to the volume input and changes the volume state as it is changed in the input. A template literal string is passed to the display showing that the volume is being changed and calculating and rounding the number associated with it appropriately. 
    
    The JSX in the main function returns the content as a grid, starting with the button grid component with the play audio event handler passed to it as a prop. Next is the control panel, which starts with the power switch component, which has the state for the switch passed to it as a prop as well as the function for updating that state passed to it via onChange prop. The console screen which shows the updated display state and the volume slider follow to complete the control panel. 
    
    I learned from making this project how to work with audio elements and how to map buttons to a grid. Mapping the buttons proved to be especially useful, as it eliminated much repetition from the JSX code in the drum machine buttons component, allowing me to display the buttons and the data associated with them dynamically. I had an array of objects for each button with the id, key, and audio source getting mapped to each button. I used the key-value pairs for the letter of each button to display the letter on the page and pass it to the function to play the correct audio.    
    `
  },
  {
    id: 3,
    link: 'https://codepen.io/joshleewillis/full/yLdPLvX',
    src: './src/assets/Project-Screenshots/5.MarkdownPreviewer.PNG', 
    title: 'Markdown Previewer', 
    description: `After familiarizing myself with the basics of React, I continued working on the projects for the FreeCodeCamp Front End Development Libraries course with the Markdown Previewer. I also used the Marked JS Library on this project. This program allows users to write GitHub flavored markdown text into a text editor, and see the results in the preview as they type. 

    The app consists of two components: a main component for the functionality of the app and the JSX structure, and another for the default content that will be displayed on load. I also wrote a short preprocessing function for the markdown to replace line-breaks with two spaces, which denotes a line-break in markdown. 
    
    The only state I used is for the text editor, and I used useEffect to load the default content component in the text editor after the initial render so that users can see markdown text in the editor and the formatted version of the content in the preview as an example. There is an event handler function passed to the preview to render its content as markdown by using the preprocessing helper function and returning it as markdown using the marked library. There is another event handler passed to the text editor to show changes based on user input. 
    
    This project continued to expand my knowledge of React and served as a brief introduction to markdown. It also allowed me to get more practice with making components, event handlers, and helper functions that work together as the functional architecture to achieve the desired result of the program. 
    `
  },
  {
    id: 4,
    link:'https://codepen.io/joshleewillis/full/yLdggwY',
    src: './src/assets/Project-Screenshots/4.To-DoList-ReactJS.PNG',
    title: 'To-Do List - React JS',
    description: `This app was the first project that I built using React. Functionally and visually, this app works the same as the Vanilla JS To-Do List, and the first paragraph of the description for that project can be referenced for a basic rundown of how it works. The CSS code is identical, however, the JavaScript code saw me working with React components for the first time to put together the functional infrastructure. The purpose of this project was to reverse engineer the Vanilla JS version of this app in React to gain a solid understanding of how to write React code and work with components.

    There are two components that comprise the React portion of the code: one for the To-Do App, which is the main component, and another for the To-Do Component. Most of the functionality and JSX is in the main component, whereas the second component handles the structure of the to-do items that get created and the function for deleting them.
    
    I implemented the hooks useState and useEffect for the first time in my code for this project. I set states for the to-do items array, the new to-do item, and the new to-do date.I used useEffect to handle local storage of the to-do items array, saving it if the dependencies for that array changed, otherwise setting it as an empty array. I used another useEffect for adding and removing the event listener for adding to-do items by pressing the ‘Enter’ key. Once again, the dependencies for this included the to-do items array, in addition to the new to-do item and new to-do date. I made event handlers within the main component to handle to-do items, handle deleting to-do items, and a helper function to check for empty fields. The handle to-do function worked similarly to my function to add items in the Vanilla JS version by adding the new to-do item to the array as an object, first using the helper function to return if there are any empty fields. The delete function filters the array by id and deletes the appropriate to-do item for the button that is pressed.
    
    I wrote the JSX for the project similarly to the HTML for the Vanilla JS version and mapped new to-do items to the array using the to-do component. I passed the component the appropriate parameters to insert the data for each to-do item in addition to the function to delete the item object when the delete button is pressed. 
    
    This project helped me cement an important foundation with React by learning the basics of writing components and making them work together appropriately, using state to reflect user input and display it on the page, and using basic hooks like useState and useEffect to manage and update state and manipulate the DOM. The reverse engineering process was also highly valuable because it gave me the chance to write a React program that I had already written in JavaScript. This helped me expand my knowledge of the JavaScript ecosystem to build upon what I had already been practicing and start creating projects in React.
    `
  },
  {
    id: 5,
    link:'https://codepen.io/joshleewillis/full/qBwaxBR',
    src: './src/assets/Project-Screenshots/3.To-DoList-VanillaJS.PNG',
    title: 'To-Do List - Vanilla JS',
    description: `This app is a simple to-do list that I created using HTML, CSS, and JavaScript. Users can simply type their to-do item into the input box, select a date from the calendar in the date input, and either press the ‘Enter’ key or click the ‘Add Item’ button to add their to-do item to the list. The item is displayed at the bottom of the list as they typed it along with the date they selected, and a delete button for that item. Pressing the delete button next to a to-do item removes it from the list. 

    Making this project helped me expand on what I learned through the ones I made before it, such as adding and removing data from arrays, accessing and displaying data from objects, using template literal strings to display data dynamically, and using local storage to save data across refreshes and browser closes.
    
    The project is comprised of two main functions: one to render the to-do list to the page, and another to add items to the to-do list. In the render function, data for the to-do name and date is stored in a destructured object. I learned how to use a template literal string to write the HTML code for the new to-do item and inserted the placeholder name and date variables to add it to the list and display it on the page. The list is saved in local storage when it is not empty. Another part of this function involves a query selector for the delete button, essentially splicing it from the list when the delete button for that to-do item is pressed.
    
    The function for adding the to-do item to the list starts by getting the name and date input elements by id and saving their values to variables. They are then pushed to the to-do list array as an object, and there is a condition in place to prevent blank name and date values from being passed through. The render function is called at the end of this function to display everything on the page. Lastly, there is a query selector for the ‘add item’ button, and an event listener for the ‘Enter’ keydown. 
    
    This project allowed me to create something functionally simple and easy to follow. Given that it was one of my early JavaScript programs, it expanded my knowledge using that tool in conjunction with HTML and CSS to add functionality to my webpages.    
    `
  },
  {
    id: 6,
    link:'https://codepen.io/joshleewillis/full/ExrrPdZ',
    src: './src/assets/Project-Screenshots/2.RockPaperScissorsGame.PNG',
    title: 'Rock Paper Scissors Game',
    description: `I made this game using HTML, CSS, and JavaScript. Users are able to play the game by clicking the icons for each move or with key down events for the first letter corresponding to each move. The game result displays on the page using the icons, showing the user move and computer move. The program keeps track of the user’s score, which they can choose to reset by clicking the reset button. The user can even make the computer play against itself once per second by using the auto-play feature, and clicking the same button stops auto-play. 
    
    Creating this project showed me how to write more concise functions that can work together at appropriate times. For instance, there are functions for randomly picking a computer move, displaying the game result, and updating the score, all of which are called inside the function to play the game. By splitting the functions up to perform their necessary tasks, the code is easier to read and the program runs more efficiently. 
    
    I also learned how to use local storage to save data through refreshes and browser closes, and how to set intervals to make a function run at a specified interval. Local storage is what I used for saving the user’s score, allowing them to still see it even if they refresh the page or close and reopen the browser. The local storage item gets removed in the reset score function, setting everything back to zero. Using the set interval function, I made the auto-play function to make the game play against itself once per second when called. The interval is cleared when the button is pressed again and the function stops running. 
    
    Lastly, I learned to use query selectors and template literal strings with variable placeholders. In order to run the appropriate function with the correct parameters when buttons are clicked, I used query selectors to connect functions and their parameters to the appropriate buttons. This allowed for cleaner HTML code and less repetition. Template literal strings were what I used in the function to display the game result in order to display the correct move icons at the end of the game. I wrapped the link to the image icon for the user and computer moves in template literal strings and used placeholders for their respective variables in the section of the link where the move name would be. This allowed me to dynamically display the move icon chosen for both the user and computer moves each time the game is played. 
    
    This project was a real game changer for me. At the time that I was writing this program, I was simultaneously studying clean code principles and best practices and applying them to my work. Making my functions concise and more focused is an example of that. I was also learning and applying more of the built-in features of JavaScript that I mentioned above. Learning and practicing these principles and applying them through this project helped me move forward with my knowledge of JavaScript and dynamic programming, and served as a precursor to get started on working with JavaScript libraries such as React.`
  },
  {
    id: 7,
    link:'https://codepen.io/joshleewillis/full/MWZboPm',
    src: './src/assets/Project-Screenshots/1.RandomQuoteMachine.PNG',
    title: 'Random Quote Machine',
    description: `My first project using HTML, CSS, and JavaScript all together, as well as jQuery. I built it as part of the FreeCodeCamp curriculum in the Front End Development Libraries course. A random quote is generated on load and each time the user presses the “New Quote” button. The quote and author key value pairs are stored inside objects organized inside an array. Used quotes are stored inside a queue array that is cleared when they are all used and the cycle resets. Each time a new quote loads, a new color scheme fades in for the page. This project helped teach me about manipulating data in arrays through indexing and other various JavaScript methods in order to display data on the page for users when actions are performed.`
  }
];

export default projectArray;